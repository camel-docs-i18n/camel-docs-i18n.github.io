<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
<head>
    <link href="//camel.apache.org/styles/site.css" rel="stylesheet" type="text/css">
    <link href="//camel.apache.org/styles/type-settings.css" rel="stylesheet" type="text/css">
<!-- <script src="//camel.apache.org/styles/prototype.js" type="text/javascript"></script>
    <script src="//camel.apache.org/styles/rico.js" type="text/javascript"></script>    
    <script src="//camel.apache.org/styles/site.js" type="text/javascript"></script> -->

    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">

    <style type="text/css">
      .maincontent { overflow:hidden; }
    </style>
    <!--[if IE]>
    <style type="text/css">
      .maincontent { width:100%; }
    </style>
    <![endif]-->


  <link href='//camel.apache.org/styles/highlighter/styles/shCoreCamel.css' rel='stylesheet' type='text/css' />
  <link href='//camel.apache.org/styles/highlighter/styles/shThemeCamel.css' rel='stylesheet' type='text/css' />
  <script src='//camel.apache.org/styles/highlighter/scripts/shCore.js' type='text/javascript'></script>
  <script src='//camel.apache.org/styles/highlighter/scripts/shBrushJava.js' type='text/javascript'></script>
  <script src='//camel.apache.org/styles/highlighter/scripts/shBrushXml.js' type='text/javascript'></script>
  <script src='//camel.apache.org/styles/highlighter/scripts/shBrushPlain.js' type='text/javascript'></script>
  
  <script type="text/javascript">
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
  </script>

    <title>
    Apache Camel: JMS
    </title>
<script type="text/javascript">window.liveSettings={api_key:"9bc4339107134d7498f2c68a7d3db5ee"};</script><script type="text/javascript" src="//cdn.transifex.com/live.js"></script></head>
<body>
<div class="white_box">
<div class="header">
  <div class="header_l">
    <div class="header_r">
    </div>
  </div>
</div>
<div class="content">
  <div class="content_l">
    <div class="content_r">
      <div>
          <!-- Banner -->
<div id="banner-content"><div id="asf_logo">
	<div id="activemq_logo" style="height:108px; background:transparent url(//camel.apache.org/banner.data/apache-camel-7.png) no-repeat scroll left top;">
            <a shape="rect" style="float:left; width:310px;display:block;text-indent:-5000px;text-decoration:none;line-height:140px; margin-top:20px; margin-left:18px;" href="http://camel.apache.org/">Camel</a>
            <a shape="rect" style="float:right; width:180px;display:block;text-indent:-5000px;text-decoration:none;line-height:80px; margin-top:45px; margin-right:10px;" href="http://www.apache.org">Apache</a>
	</div>
</div></div>
          <!-- Banner -->
        <div class="top_red_bar">
          <div id="site-breadcrumbs">
                <!-- Breadcrumbs -->
<a href="index.html">Apache Camel</a>&nbsp;&gt;&nbsp;<a href="documentation.html">Documentation</a>&nbsp;&gt;&nbsp;<a href="components.html">Components</a>&nbsp;&gt;&nbsp;<a href="jms.html">JMS</a>
          </div>
          <!-- Quicklinks -->
<div id="site-quicklinks"><p><a shape="rect" href="download.html">Download</a> | <a shape="rect" href="javadoc.html">JavaDoc</a> | <a shape="rect" href="source.html">Source</a> | <a shape="rect" href="discussion-forums.html">Forums</a> | <a shape="rect" href="support.html">Support</a></p></div>
          <!-- Quicklinks -->
        </div>

	<table border="0">
	<tbody>
        <tr>
        <td valign="top" width="100%">
<div class="wiki-content maincontent"><h2 id="JMS-JMSComponent">JMS Component</h2><div class="confluence-information-macro confluence-information-macro-information"><p class="title">Using ActiveMQ</p><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>If you are using <a shape="rect" class="external-link" href="http://activemq.apache.org/">Apache ActiveMQ</a>, you should prefer the <a shape="rect" href="activemq.html">ActiveMQ</a> component as it has been optimized for <a shape="rect" href="activemq.html">ActiveMQ</a>. All of the options and samples on this page are also valid for the <a shape="rect" href="activemq.html">ActiveMQ</a> component.</p></div></div><div class="confluence-information-macro confluence-information-macro-tip"><p class="title">Transacted and caching</p><span class="aui-icon aui-icon-small aui-iconfont-approve confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>See section <em>Transactions and Cache Levels</em> below if you are using transactions with <a shape="rect" href="jms.html">JMS</a> as it can impact performance.</p></div></div><div class="confluence-information-macro confluence-information-macro-tip"><p class="title">Request/Reply over JMS</p><span class="aui-icon aui-icon-small aui-iconfont-approve confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>Make sure to read the section <em>Request-reply over JMS</em> further below on this page for important notes about request/reply, as Camel offers a number of options to configure for performance, and clustered environments.</p></div></div><p>This&#160;component allows messages to be sent to (or consumed from) a <a shape="rect" class="external-link" href="http://java.sun.com/products/jms/" rel="nofollow">JMS</a> Queue or Topic. It uses Spring's JMS support for declarative transactions, including Spring's <code>JmsTemplate</code> for sending and a <code>MessageListenerContainer</code> for consuming.</p><p>Maven users will need to add the following dependency to their <code>pom.xml</code> for this component:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: xml; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[&lt;dependency&gt;
    &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
    &lt;artifactId&gt;camel-jms&lt;/artifactId&gt;
    &lt;version&gt;x.x.x&lt;/version&gt;
    &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;
]]></script>
</div></div><h3 id="JMS-URIformat">URI format</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[jms:[queue:|topic:]destinationName[?options]
]]></script>
</div></div><p>Where <code>destinationName</code> is a JMS queue or topic name. By default, the <code>destinationName</code> is interpreted as a queue name. For example, to connect to the queue, <code>FOO.BAR</code> use:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[jms:FOO.BAR
]]></script>
</div></div><p>You can include the optional <code>queue:</code> prefix, if you prefer:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[jms:queue:FOO.BAR
]]></script>
</div></div><p>To connect to a topic, you <em>must</em> include the <code>topic:</code> prefix. For example, to<br clear="none"> connect to the topic, <code>Stocks.Prices</code>, use:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[jms:topic:Stocks.Prices
]]></script>
</div></div><p>You append query options to the URI using the following format, <code>?option=value&amp;option=value&amp;...</code></p><h3 id="JMS-Notes">Notes</h3><h4 id="JMS-UsingActiveMQ">Using ActiveMQ</h4><p>The JMS component reuses Spring 2's <code>JmsTemplate</code> for sending messages. This is not ideal for use in a non-J2EE container and typically requires some caching in the JMS provider to avoid <a shape="rect" class="external-link" href="http://activemq.apache.org/jmstemplate-gotchas.html">poor performance</a>.</p><p>If you intend to use <a shape="rect" class="external-link" href="http://activemq.apache.org/">Apache ActiveMQ</a> as your Message Broker - which is a good choice as ActiveMQ rocks <img class="emoticon emoticon-smile" src="https://cwiki.apache.org/confluence/s/en_GB/5982/f2b47fb3d636c8bc9fd0b11c0ec6d0ae18646be7.1/_/images/icons/emoticons/smile.png" data-emoticon-name="smile" alt="(smile)"> , then we recommend that you either:</p><ul><li>Use the <a shape="rect" href="activemq.html">ActiveMQ</a> component, which is already optimized to use ActiveMQ efficiently</li><li>Use the <code>PoolingConnectionFactory</code> in ActiveMQ.</li></ul><h4 id="JMS-TransactionsandCacheLevels">Transactions and Cache Levels</h4><p><span class="confluence-anchor-link" id="JMS-transactionCacheLevels"></span><br clear="none"> If you are consuming messages and using transactions (<code>transacted=true</code>) then the default settings for cache level can impact performance.<br clear="none"> If you are using XA transactions then you cannot cache as it can cause the XA transaction to not work properly.</p><p>If you are <strong>not</strong> using XA, then you should consider caching as it speeds up performance, such as setting <code>cacheLevelName=CACHE_CONSUMER</code>.</p><p>Through Camel 2.7.x, the default setting for <code>cacheLevelName</code> is <code>CACHE_CONSUMER</code>. You will need to explicitly set <code>cacheLevelName=CACHE_NONE</code>.<br clear="none"> In Camel 2.8 onwards, the default setting for <code>cacheLevelName</code> is <code>CACHE_AUTO</code>. This default auto detects the mode and sets the cache level accordingly to:</p><ul class="alternate"><li>CACHE_CONSUMER = if transacted=false</li><li>CACHE_NONE = if transacted=true</li></ul><p>So you can say the default setting is conservative. Consider using <code>cacheLevelName=CACHE_CONSUMER</code> if you are using non-XA transactions.</p><h4 id="JMS-DurableSubscriptions">Durable Subscriptions</h4><p>If you wish to use durable topic subscriptions, you need to specify both <strong>clientId</strong> and <strong>durableSubscriptionName</strong>. The value of the <code>clientId</code> must be unique and can only be used by a single JMS connection instance in your entire network. You may prefer to use <a shape="rect" class="external-link" href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a> instead to avoid this limitation. More background on durable messaging <a shape="rect" class="external-link" href="http://activemq.apache.org/how-do-durable-queues-and-topics-work.html">here</a>.</p><h4 id="JMS-MessageHeaderMapping">Message Header Mapping</h4><p>When using message headers, the JMS specification states that header names must be valid Java identifiers. So try to name your headers to be valid Java identifiers. One benefit of doing this is that you can then use your headers inside a JMS Selector (whose SQL92 syntax mandates Java identifier syntax for headers).</p><p>A simple strategy for mapping header names is used by default. The strategy is to replace any dots and hyphens in the header name as shown below and to reverse the replacement when the header name is restored from a JMS message sent over the wire. What does this mean? No more losing method names to invoke on a bean component, no more losing the filename header for the File Component, and so on.</p><p>The current header name strategy for accepting header names in Camel is as follows:</p><ul class="alternate"><li>Dots are replaced by <code>_DOT_</code> and the replacement is reversed when Camel consume the message</li><li>Hyphen is replaced by <code>_HYPHEN_</code> and the replacement is reversed when Camel consumes the message</li></ul><h3 id="JMS-Options">Options</h3><p>You can configure many different properties on the JMS endpoint which map to properties on the <a shape="rect" class="external-link" href="http://camel.apache.org/maven/current/camel-jms/apidocs/org/apache/camel/component/jms/JmsConfiguration.html">JMSConfiguration POJO</a>.</p><div class="confluence-information-macro confluence-information-macro-note"><p class="title">Mapping to Spring JMS</p><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>Many of these properties map to properties on Spring JMS, which Camel uses for sending and receiving messages. So you can get more information about these properties by consulting the relevant Spring documentation.</p></div></div><p>The options are divided into two tables, the first one with the most common options used. The latter contains the rest.</p><h4 id="JMS-Mostcommonlyusedoptions">Most commonly used options</h4><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Option</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Default Value</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>clientId</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. You may prefer to use <a shape="rect" class="external-link" href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a> instead.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>concurrentConsumers</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies the default number of concurrent consumers. From <strong>Camel 2.10.3</strong> onwards this option can also be used when doing request/reply over JMS. From <strong>Camel 2.16</strong> onwards there is a new replyToConcurrentConsumers. See also the <code>maxMessagesPerTask</code> option to control dynamic scaling up/down of threads.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><code>replyToConcurrentConsumers</code></td><td colspan="1" rowspan="1" class="confluenceTd">1</td><td colspan="1" rowspan="1" class="confluenceTd"><strong>Camel 2.16:</strong> <span>Specifies the default number of concurrent consumers when doing request/reply over JMS.</span></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>disableReplyTo</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>If <code>true</code>, a producer will behave like a InOnly exchange with the exception that <code>JMSReplyTo</code> header is sent out and not be suppressed like in the case of <code>InOnly</code>. Like <code>InOnly</code> the producer will not wait for a reply. A consumer with this flag will behave like <code>InOnly</code>. This feature can be used to bridge <code>InOut</code> requests to another queue so that a route on the other queue will send it&#180;s response directly back to the original <code>JMSReplyTo</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>durableSubscriptionName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The durable subscriber name for specifying durable topic subscriptions. The <code>clientId</code> option <strong>must</strong> be configured as well.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maxConcurrentConsumers</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies the maximum number of concurrent consumers. From <strong>Camel 2.10.3</strong> onwards this option can also be used when doing request/reply over JMS. <span>From </span><strong>Camel 2.16</strong><span> onwards there is a new replyToMaxConcurrentConsumers. </span>See also the <code>maxMessagesPerTask</code> option to control dynamic scaling up/down of threads. The <code>maxMessagesPerTask</code><span> option MUST be set to an integer greater than 0 for threads to scale down. Otherwise, the number of threads will stay at <span>maxConcurrentConsumers until shutdown.</span></span></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><code>replyToMaxConcurrentConsumers</code></td><td colspan="1" rowspan="1" class="confluenceTd">1</td><td colspan="1" rowspan="1" class="confluenceTd"><strong>Camel 2.16:</strong> <span>Specifies the maximum number of concurrent consumers when doing request/reply over JMS. <span>See also the </span><code>maxMessagesPerTask</code><span> option to control dynamic scaling up/down of threads.</span></span></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maxMessagesPerTask</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>-1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min &lt; max), then this option can be used to set a value to eg <code>100</code> to control how fast the consumers will shrink when less work is required.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>preserveMessageQos</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Set to <code>true</code>, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered <code>JMSPriority</code>, <code>JMSDeliveryMode</code>, and <code>JMSExpiration</code>. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The <code>explicitQosEnabled</code> option, by contrast, will only use options set on the endpoint, and not values from the message header.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>replyTo</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Provides an explicit ReplyTo destination, which overrides any incoming value of <code>Message.getJMSReplyTo()</code>. If you do <a shape="rect" href="request-reply.html">Request Reply</a> over JMS then <strong>make sure</strong> to read the section <em>Request-reply over JMS</em> further below for more details, and the <code>replyToType</code> option as well.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>replyToOverride</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.15:</strong> Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>replyToType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.9:</strong> Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: <code>Temporary</code>, <code>Shared</code>, or <code>Exclusive</code>. By default Camel will use temporary queues. However if <code>replyTo</code> has been configured, then <code>Shared</code> is used by default. This option allows you to use exclusive queues instead of shared ones. See further below for more details, and especially the notes about the implications if running in a clustered environment, and the fact that <code>Shared</code> reply queues has lower performance than its alternatives <code>Temporary</code> and <code>Exclusive</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>requestTimeout</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>20000</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Producer only:</strong> The timeout for waiting for a reply when using the InOut <a shape="rect" href="exchange-pattern.html">Exchange Pattern</a> (in milliseconds). The default is 20 seconds. From <strong>Camel 2.13/2.12.3</strong> onwards you can include the header <code>"CamelJmsRequestTimeout"</code> to override this endpoint configured timeout value, and thus have per message individual timeout values. See below in section <em>About time to live</em> for more details. See also the <em>requestTimeoutCheckerInterval</em> option.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>selector</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the JMS Selector, which is an SQL 92 predicate that is used to filter messages within the broker. You may have to encode special characters such as = as %3D <strong>Before Camel 2.3.0</strong>, we don't support this option in CamelConsumerTemplate</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>timeToLive</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>When sending messages, specifies the time-to-live of the message (in milliseconds). See below in section <em>About time to live</em> for more details.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>transacted</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether to use transacted mode for sending/receiving messages using the InOnly <a shape="rect" href="exchange-pattern.html">Exchange Pattern</a>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>testConnectionOnStartup</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.1:</strong> Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. From <strong>Camel 2.8</strong> onwards also the JMS producers is tested as well.</p></td></tr></tbody></table></div><h4 id="JMS-Alltheotheroptions">All the other options</h4><div class="confluenceTableSmall">&#160;</div><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Option</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Default Value</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>acceptMessagesWhileStopping</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop <a shape="rect" href="jms.html">JMS</a> routes at runtime, while there are still messages enqued on the queue. If this option is <code>false</code>, and you stop the <a shape="rect" href="jms.html">JMS</a> route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>acknowledgementModeName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>AUTO_ACKNOWLEDGE</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS acknowledgement name, which is one of: <code>SESSION_TRANSACTED</code>, <code>CLIENT_ACKNOWLEDGE</code>, <code>AUTO_ACKNOWLEDGE</code>, <code>DUPS_OK_ACKNOWLEDGE</code></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>acknowledgementMode</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>-1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS acknowledgement mode defined as an Integer. Allows you to set vendor-specific extensions to the acknowledgment mode. For the regular modes, it is preferable to use the <code>acknowledgementModeName</code> instead.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>allowNullBody</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.9.3/2.10.1:</strong> Whether to allow sending messages with no body. If this option is <code>false</code> and the message body is null, then an <code>JMSException</code> is thrown.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>alwaysCopyMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>If <code>true</code>, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a <code>replyToDestinationSelectorName</code> is set (incidentally, Camel will set the <code>alwaysCopyMessage</code> option to <code>true</code>, if a <code>replyToDestinationSelectorName</code> is set)</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>asyncConsumer</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.9:</strong> Whether the <code>JmsConsumer</code> processes the <a shape="rect" href="exchange.html">Exchange</a> <a shape="rect" href="asynchronous-routing-engine.html">asynchronously</a>. If enabled then the <code>JmsConsumer</code> may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the <a shape="rect" href="asynchronous-routing-engine.html">Asynchronous Routing Engine</a>). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the <a shape="rect" href="exchange.html">Exchange</a> is fully processed before the <code>JmsConsumer</code> will pickup the next message from the JMS queue. Note if <code>transacted</code> has been enabled, then <code>asyncConsumer=true</code> does not run asynchronously, as transactions must be executed synchronously (Camel 3.0 may support async transactions).</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>asyncStartListener</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.10:</strong> Whether to startup the <code>JmsConsumer</code> message listener asynchronously, when starting a route. For example if a <code>JmsConsumer</code> cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to <code>true</code>, you will let routes startup, while the <code>JmsConsumer</code> connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at <code>WARN</code> level, and the consumer will not be able to receive messages; You can then restart the route to retry.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>asyncStopListener</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.10:</strong> Whether to stop the <code>JmsConsumer</code> message listener asynchronously, when stopping a route.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>autoStartup</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether the consumer container should auto-startup.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>cacheLevelName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>CACHE_AUTO (Camel &gt;= 2.8.0)<br clear="none" class="atl-forced-newline"> CACHE_CONSUMER (Camel &lt;= 2.7.1)</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the cache level by name for the underlying JMS resources. Possible values are: <code>CACHE_AUTO</code>, <code>CACHE_CONNECTION</code>, <code>CACHE_CONSUMER</code>, <code>CACHE_NONE</code>, and <code>CACHE_SESSION</code>. The default setting for <strong>Camel 2.8</strong> and newer is <code>CACHE_AUTO</code>. For <strong>Camel 2.7.1</strong> and older the default is <code>CACHE_CONSUMER</code>. See the <a shape="rect" class="external-link" href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jms/listener/DefaultMessageListenerContainer.html" rel="nofollow">Spring documentation</a> and <a shape="rect" href="#JMS-transactionCacheLevels">Transactions Cache Levels</a> for more information.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>cacheLevel</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the cache level by ID for the underlying JMS resources. See <code>cacheLevelName</code> option for more details.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>consumerType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Default</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The consumer type to use, which can be one of: <code>Simple</code>, <code>Default</code>, or <code>Custom</code>. The consumer type determines which Spring JMS listener to use. <code>Default</code> will use <code>org.springframework.jms.listener.DefaultMessageListenerContainer</code>, <code>Simple</code> will use <code>org.springframework.jms.listener.SimpleMessageListenerContainer</code>. When <code>Custom</code> is specified, the <code>MessageListenerContainerFactory</code> defined by the <code>messageListenerContainerFactoryRef</code> option will determine what <code>org.springframework.jms.listener.AbstractMessageListenerContainer</code> to use (<strong>new option in Camel 2.10.2 onwards</strong>). This option was temporary removed in Camel 2.7 and 2.8. But has been added back from Camel 2.9 onwards.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>connectionFactory</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The default JMS connection factory to use for the <code>listenerConnectionFactory</code> and <code>templateConnectionFactory</code>, if neither is specified.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>defaultTaskExecutorType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>(see description)</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.10.4:</strong> Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: <code>SimpleAsync</code> (uses Spring's <a shape="rect" class="external-link" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html" rel="nofollow">SimpleAsyncTaskExecutor</a>) or <code>ThreadPool</code> (uses Spring's <a shape="rect" class="external-link" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html" rel="nofollow">ThreadPoolTaskExecutor</a> with optimal values - cached threadpool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of <code>ThreadPool</code> is recommended to reduce "thread trash" in elastic configurations with dynamically increasing and decreasing concurrent consumers.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>deliveryMode</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>null</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.12.2/2.13:</strong> Specifies the delivery mode to be used. Possibles values are those defined by <code>javax.jms.DeliveryMode</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>deliveryPersistent</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether persistent delivery is used by default.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>destination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies the JMS Destination object to use on this endpoint.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>destinationName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies the JMS destination name to use on this endpoint.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>destinationResolver</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>A pluggable <code>org.springframework.jms.support.destination.DestinationResolver</code> that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>disableTimeToLive</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.8:</strong> Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the <code>requestTimeout</code> value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use <code>disableTimeToLive=true</code> to <strong>not</strong> set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section <em>About time to live</em> for more details.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>eagerLoadingOfProperties</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Enables eager loading of JMS properties as soon as a message is received, which is generally inefficient, because the JMS properties might not be required. But this feature can sometimes catch early any issues with the underlying JMS provider and the use of JMS properties. This feature can also be used for testing purposes, to ensure JMS properties can be understood and handled correctly.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>exceptionListener</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>errorHandler</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.8.2, 2.9:</strong> Specifies a <code>org.springframework.util.ErrorHandler</code> to be invoked in case of any uncaught exceptions thrown while processing a <code>Message</code>. By default these exceptions will be logged at the WARN level, if no <code>errorHandler</code> has been configured. From <strong>Camel 2.9.1:</strong> onwards you can configure logging level and whether stack traces should be logged using the below two options. This makes it much easier to configure, than having to code a custom <code>errorHandler</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>errorHandlerLoggingLevel</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>WARN</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.9.1:</strong> Allows to configure the default <code>errorHandler</code> logging level for logging uncaught exceptions.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>errorHandlerLogStackTrace</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.9.1:</strong> Allows to control whether stacktraces should be logged or not, by the default <code>errorHandler</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>explicitQosEnabled</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Set if the <code>deliveryMode</code>, <code>priority</code> or <code>timeToLive</code> qualities of service should be used when sending messages. This option is based on Spring's <code>JmsTemplate</code>. The <code>deliveryMode</code>, <code>priority</code> and <code>timeToLive</code> options are applied to the current endpoint. This contrasts with the <code>preserveMessageQos</code> option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>exposeListenerSession</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether the listener session should be exposed when consuming messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>forceSendOriginalMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.7:</strong> When using <code>mapJmsMessage=false</code> Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to <code>true</code> to force Camel to send the original JMS message that was received.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>idleTaskExecutionLimit</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the <code>maxConcurrentConsumers</code> setting). There is additional doc available from <a shape="rect" class="external-link" href="http://static.springsource.org/spring/docs/3.0.5.RELEASE/api/org/springframework/jms/listener/DefaultMessageListenerContainer.html#setIdleTaskExecutionLimit(int)" rel="nofollow">Spring</a>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>idleConsumerLimit</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.8.2, 2.9:</strong> Specify the limit for the number of consumers that are allowed to be idle at any given time.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>includeSentJMSMessageID</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.10.3:</strong> Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel <a shape="rect" href="exchange.html">Exchange</a> with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>includeAllJMSXProperties</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.11.2/2.12:</strong> Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to <code>true</code> will include properties such as <code>JMSXAppID</code>, and <code>JMSXUserID</code> etc. <strong>Note:</strong> If you are using a custom <code>headerFilterStrategy</code> then this option does not apply.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>jmsMessageType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Allows you to force the use of a specific <code>javax.jms.Message</code> implementation for sending JMS messages. Possible values are: <code>Bytes</code>, <code>Map</code>, <code>Object</code>, <code>Stream</code>, <code>Text</code>. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>jmsKeyFormatStrategy</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>default</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: <code>default</code> and <code>passthrough</code>. The <code>default</code> strategy will safely marshal dots and hyphens (<code>.</code> and <code>-</code>). The <code>passthrough</code> strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the <code>org.apache.camel.component.jms.JmsKeyFormatStrategy</code> and refer to it using the <code>#</code> notation.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>jmsOperations</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Allows you to use your own implementation of the <code>org.springframework.jms.core.JmsOperations</code> interface. Camel uses <code>JmsTemplate</code> as default. Can be used for testing purpose, but not used much as stated in the spring API docs.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>lazyCreateTransactionManager</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>If <code>true</code>, Camel will create a <code>JmsTransactionManager</code>, if there is no <code>transactionManager</code> injected when option <code>transacted=true</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>listenerConnectionFactory</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS connection factory used for consuming messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>mapJmsMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether Camel should auto map the received JMS message to an appropiate payload type, such as <code>javax.jms.TextMessage</code> to a <code>String</code> etc. See section about how mapping works below for more details.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maximumBrowseSize</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>-1</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Limits the number of messages fetched at most, when browsing endpoints using <a shape="rect" href="browse.html">Browse</a> or JMX API.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>messageConverter</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>To use a custom Spring <code>org.springframework.jms.support.converter.MessageConverter</code> so you can be 100% in control how to map to/from a <code>javax.jms.Message</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>messageIdEnabled</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>When sending, specifies whether message IDs should be added.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>messageListenerContainerFactoryRef</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.10.2:</strong> Registry ID of the <code>MessageListenerContainerFactory</code> used to determine what <code>org.springframework.jms.listener.AbstractMessageListenerContainer</code> to use to consume messages. Setting this will automatically set <code>consumerType</code> to <code>Custom</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>messageTimestampEnabled</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether timestamps should be enabled by default on sending messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>password</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The password for the connector factory.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>priority</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>4</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Values greater than 1 specify the message priority when sending (where 0 is the lowest priority and 9 is the highest). The <code>explicitQosEnabled</code> option <strong>must</strong> also be enabled in order for this option to have any effect.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>pubSubNoLocal</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether to inhibit the delivery of messages published by its own connection.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>receiveTimeout</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>1000</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The timeout for receiving messages (in milliseconds).</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>recoveryInterval</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>5000</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><code>replyToSameDestinationAllowed</code></td><td colspan="1" rowspan="1" class="confluenceTd"><code>false</code></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>Camel 2.16:</strong> <strong>Consumer only:</strong>Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>replyToCacheLevelName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>CACHE_CONSUMER</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.9.1:</strong> Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: <code>CACHE_CONSUMER</code> for exclusive or shared w/ <code>replyToSelectorName</code>. And <code>CACHE_SESSION</code> for shared without <code>replyToSelectorName</code>. Some JMS brokers such as IBM WebSphere may require to set the <code>replyToCacheLevelName=CACHE_NONE</code> to work. <strong>Note:</strong> If using temporary queues then <code>CACHE_NONE</code> is not allowed, and you must use a higher value such as <code>CACHE_CONSUMER</code> or <code>CACHE_SESSION</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>replyToDestinationSelectorName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>replyToDeliveryPersistent</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether to use persistent delivery by default for replies.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>requestTimeoutCheckerInterval</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>1000</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.9.2:</strong> Configures how often Camel should check for timed out <a shape="rect" href="exchange.html">Exchange</a>s when doing request/reply over JMS.By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option <em>requestTimeout</em>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>subscriptionDurable</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>@deprecated:</strong> Enabled by default, if you specify a <code>durableSubscriptionName</code> and a <code>clientId</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>taskExecutor</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Allows you to specify a custom task executor for consuming messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>taskExecutorSpring2</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.6:</strong> To use when using Spring 2.x with Camel. Allows you to specify a custom task executor for consuming messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>templateConnectionFactory</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS connection factory used for sending messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>transactedInOut</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>@deprecated:</strong> Specifies whether to use transacted mode for sending messages using the InOut <a shape="rect" href="exchange-pattern.html">Exchange Pattern</a>. Applies only to producer endpoints. See section <a shape="rect" href="#JMS-transactedConsumption">Enabling Transacted Consumption</a> for more details.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>transactionManager</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The Spring transaction manager to use.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>transactionName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>"JmsConsumer[destinationName]"</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The name of the transaction to use.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>transactionTimeout</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The timeout value of the transaction (in seconds), if using transacted mode.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>transferException</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>If enabled and you are using <a shape="rect" href="request-reply.html">Request Reply</a> messaging (InOut) and an <a shape="rect" href="exchange.html">Exchange</a> failed on the consumer side, then the caused <code>Exception</code> will be send back in response as a <code>javax.jms.ObjectMessage</code>. If the client is Camel, the returned <code>Exception</code> is rethrown. This allows you to use Camel <a shape="rect" href="jms.html">JMS</a> as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have <strong>transferExchange</strong> enabled, this option takes precedence. The caught exception is required to be serializable. The original <code>Exception</code> on the consumer side can be wrapped in an outer exception such as <code>org.apache.camel.RuntimeCamelException</code> when returned to the producer.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><code>transferFault</code></td><td colspan="1" rowspan="1" class="confluenceTd"><code>false</code></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>Camel 2.17:</strong> If enabled and you are using Request Reply messaging (InOut) and an Exchange failed with a SOAP fault (not exception) on the consumer side, then the fault flag on org.apache.camel.Message.isFault() will be send back in the response as a JMS header with the key JmsConstants.JMS_TRANSFER_FAULT. If the client is Camel, the returned fault flag will be set on the org.apache.camel.Message.setFault(boolean). You may want to enable this when using Camel components that support faults such as SOAP based such as cxf or spring-ws.</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>transferExchange</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at <code>WARN</code> level. You <strong>must</strong> enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>username</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>null</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The username for the connector factory.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>useMessageIDAsCorrelationID</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Specifies whether <code>JMSMessageID</code> should always be used as <code>JMSCorrelationID</code> for <strong>InOut</strong> messages.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>useVersion102</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>false</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>@deprecated (removed from Camel 2.5 onwards):</strong> Specifies whether the old JMS API should be used.</p></td></tr></tbody></table></div></div><h3 id="JMS-MessageMappingbetweenJMSandCamel">Message Mapping between JMS and Camel</h3><p>Camel automatically maps messages between <code>javax.jms.Message</code> and <code>org.apache.camel.Message</code>.</p><p>When sending a JMS message, Camel converts the message body to the following JMS message types:</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Body Type</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>JMS Message</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Comment</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>String</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.TextMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>org.w3c.dom.Node</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.TextMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The DOM will be converted to <code>String</code>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Map</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.MapMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>java.io.Serializable</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.ObjectMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>byte[]</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.BytesMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>java.io.File</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.BytesMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>java.io.Reader</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.BytesMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>java.io.InputStream</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.BytesMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>java.nio.ByteBuffer</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.BytesMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>&#160;</p></td></tr></tbody></table></div></div><p>When receiving a JMS message, Camel converts the JMS message to the following body type:</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>JMS Message</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Body Type</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.TextMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>String</code></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.BytesMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>byte[]</code></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.MapMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Map&lt;String, Object&gt;</code></p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.ObjectMessage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Object</code></p></td></tr></tbody></table></div></div><h4 id="JMS-Disablingauto-mappingofJMSmessages">Disabling auto-mapping of JMS messages</h4><p>You can use the <code>mapJmsMessage</code> option to disable the auto-mapping above. If disabled, Camel will not try to map the received JMS message, but instead uses it directly as the payload. This allows you to avoid the overhead of mapping and let Camel just pass through the JMS message. For instance, it even allows you to route <code>javax.jms.ObjectMessage</code> JMS messages with classes you do <strong>not</strong> have on the classpath.</p><h4 id="JMS-UsingacustomMessageConverter">Using a custom MessageConverter</h4><p>You can use the <code>messageConverter</code> option to do the mapping yourself in a Spring <code>org.springframework.jms.support.converter.MessageConverter</code> class.</p><p>For example, in the route below we use a custom message converter when sending a message to the JMS order queue:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[  from(&quot;file://inbox/order&quot;).to(&quot;jms:queue:order?messageConverter=#myMessageConverter&quot;);
]]></script>
</div></div><p>You can also use a custom message converter when consuming from a JMS destination.</p><h4 id="JMS-Controllingthemappingstrategyselected">Controlling the mapping strategy selected</h4><p>You can use the <strong>jmsMessageType</strong> option on the endpoint URL to force a specific message type for all messages.<br clear="none"> In the route below, we poll files from a folder and send them as <code>javax.jms.TextMessage</code> as we have forced the JMS producer endpoint to use text messages:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[  from(&quot;file://inbox/order&quot;).to(&quot;jms:queue:order?jmsMessageType=Text&quot;);
]]></script>
</div></div><p>You can also specify the message type to use for each messabe by setting the header with the key <code>CamelJmsMessageType</code>. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[  from(&quot;file://inbox/order&quot;).setHeader(&quot;CamelJmsMessageType&quot;, JmsMessageType.Text).to(&quot;jms:queue:order&quot;);
]]></script>
</div></div><p>The possible values are defined in the <code>enum</code> class, <code>org.apache.camel.jms.JmsMessageType</code>.</p><h3 id="JMS-Messageformatwhensending">Message format when sending</h3><p>The exchange that is sent over the JMS wire must conform to the <a shape="rect" class="external-link" href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" rel="nofollow">JMS Message spec</a>.</p><p>For the <code>exchange.in.header</code> the following rules apply for the header <strong>keys</strong>:</p><ul class="alternate"><li>Keys starting with <code>JMS</code> or <code>JMSX</code> are reserved.</li><li><code>exchange.in.headers</code> keys must be literals and all be valid Java identifiers (do not use dots in the key name).</li><li>Camel replaces dots &amp; hyphens and the reverse when when consuming JMS messages:<br clear="none"> <code>.</code> is replaced by <code>_DOT_</code> and the reverse replacement when Camel consumes the message.<br clear="none"> <code>-</code> is replaced by <code>_HYPHEN_</code> and the reverse replacement when Camel consumes the message.</li><li>See also the option <code>jmsKeyFormatStrategy</code>, which allows use of your own custom strategy for formatting keys.</li></ul><p>For the <code>exchange.in.header</code>, the following rules apply for the header <strong>values</strong>:</p><ul class="alternate"><li>The values must be primitives or their counter objects (such as <code>Integer</code>, <code>Long</code>, <code>Character</code>). The types, <code>String</code>, <code>CharSequence</code>, <code>Date</code>, <code>BigDecimal</code> and <code>BigInteger</code> are all converted to their <code>toString()</code> representation. All other types are dropped.</li></ul><p>Camel will log with category <code>org.apache.camel.component.jms.JmsBinding</code> at <strong>DEBUG</strong> level if it drops a given header value. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[2008-07-09 06:43:04,046 [main           ] DEBUG JmsBinding
  - Ignoring non primitive header: order of class: org.apache.camel.component.jms.issues.DummyOrder with value: DummyOrder{orderId=333, itemId=4444, quantity=2}
]]></script>
</div></div><h3 id="JMS-Messageformatwhenreceiving">Message format when receiving</h3><p>Camel adds the following properties to the <code>Exchange</code> when it receives a message:</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Property</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Type</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>org.apache.camel.jms.replyDestination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.Destination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The reply destination.</p></td></tr></tbody></table></div></div><p>Camel adds the following JMS properties to the In message headers when it receives a JMS message:</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Header</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Type</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSCorrelationID</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>String</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS correlation ID.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSDeliveryMode</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>int</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS delivery mode.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSDestination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.Destination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS destination.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSExpiration</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>long</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS expiration.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSMessageID</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>String</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS unique message ID.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSPriority</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>int</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS priority (with 0 as the lowest priority and 9 as the highest).</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSRedelivered</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>boolean</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Is the JMS message redelivered.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSReplyTo</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.Destination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS reply-to destination.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSTimestamp</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>long</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS timestamp.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>String</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS type.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSXGroupID</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>String</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The JMS group ID.</p></td></tr></tbody></table></div></div><p>As all the above information is standard JMS you can check the <a shape="rect" class="external-link" href="http://java.sun.com/javaee/5/docs/api/javax/jms/Message.html" rel="nofollow">JMS documentation</a> for further details.</p><h3 id="JMS-AboutusingCameltosendandreceivemessagesandJMSReplyTo">About using Camel to send and receive messages and JMSReplyTo</h3><p>The JMS component is complex and you have to pay close attention to how it works in some cases. So this is a short summary of some of the areas/pitfalls to look for.</p><p>When Camel sends a message using its <code>JMSProducer</code>, it checks the following conditions:</p><ul class="alternate"><li>The message exchange pattern,</li><li>Whether a <code>JMSReplyTo</code> was set in the endpoint or in the message headers,</li><li>Whether any of the following options have been set on the JMS endpoint: <code>disableReplyTo</code>, <code>preserveMessageQos</code>, <code>explicitQosEnabled</code>.</li></ul><p>All this can be a tad complex to understand and configure to support your use case.</p><h4 id="JMS-JmsProducer">JmsProducer</h4><p>The <code>JmsProducer</code> behaves as follows, depending on configuration:</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Exchange Pattern</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Other options</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><em>InOut</em></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>-</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Camel will expect a reply, set a temporary <code>JMSReplyTo</code>, and after sending the message, it will start to listen for the reply message on the temporary queue.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><em>InOut</em></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSReplyTo</code> is set</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Camel will expect a reply and, after sending the message, it will start to listen for the reply message on the specified <code>JMSReplyTo</code> queue.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><em>InOnly</em></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>-</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Camel will send the message and <strong>not</strong> expect a reply.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><em>InOnly</em></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>JMSReplyTo</code> is set</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>By default, Camel discards the <code>JMSReplyTo</code> destination and clears the <code>JMSReplyTo</code> header before sending the message. Camel then sends the message and does <strong>not</strong> expect a reply. Camel logs this in the log at <code>WARN</code> level (changed to <code>DEBUG</code> level from <strong>Camel 2.6</strong> onwards. You can use <code>preserveMessageQuo=true</code> to instruct Camel to keep the <code>JMSReplyTo</code>. In all situations the <code>JmsProducer</code> does <strong>not</strong> expect any reply and thus continue after sending the message.</p></td></tr></tbody></table></div></div><h4 id="JMS-JmsConsumer">JmsConsumer</h4><p>The <code>JmsConsumer</code> behaves as follows, depending on configuration:</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Exchange Pattern</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Other options</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><em>InOut</em></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>-</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Camel will send the reply back to the <code>JMSReplyTo</code> queue.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><em>InOnly</em></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>-</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Camel will not send a reply back, as the pattern is <em>InOnly</em>.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>-</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>disableReplyTo=true</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>This option suppresses replies.</p></td></tr></tbody></table></div></div><p>So pay attention to the message exchange pattern set on your exchanges.</p><p>If you send a message to a JMS destination in the middle of your route you can specify the exchange pattern to use, see more at <a shape="rect" href="request-reply.html">Request Reply</a>.<br clear="none"> This is useful if you want to send an <code>InOnly</code> message to a JMS topic:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(&quot;activemq:queue:in&quot;)
   .to(&quot;bean:validateOrder&quot;)
   .to(ExchangePattern.InOnly, &quot;activemq:topic:order&quot;)
   .to(&quot;bean:handleOrder&quot;);
]]></script>
</div></div><h3 id="JMS-Reuseendpointandsendtodifferentdestinationscomputedatruntime">Reuse endpoint and send to different destinations computed at runtime</h3><p>If you need to send messages to a lot of different JMS destinations, it makes sense to reuse a JMS endpoint and specify the real destination in a message header. This allows Camel to reuse the same endpoint, but send to different destinations. This greatly reduces the number of endpoints created and economizes on memory and thread resources.</p><p>You can specify the destination in the following headers:</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Header</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Type</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>CamelJmsDestination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>javax.jms.Destination</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>A destination object.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>CamelJmsDestinationName</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>String</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>The destination name.</p></td></tr></tbody></table></div></div><p>For example, the following route shows how you can compute a destination at run time and use it to override the destination appearing in the JMS URL:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(&quot;file://inbox&quot;)
  .to(&quot;bean:computeDestination&quot;)
  .to(&quot;activemq:queue:dummy&quot;);
]]></script>
</div></div><p>The queue name, <code>dummy</code>, is just a placeholder. It must be provided as part of the JMS endpoint URL, but it will be ignored in this example.</p><p>In the <code>computeDestination</code> bean, specify the real destination by setting the <code>CamelJmsDestinationName</code> header as follows:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[public void setJmsHeader(Exchange exchange) {
   String id = ....
   exchange.getIn().setHeader(&quot;CamelJmsDestinationName&quot;, &quot;order:&quot; + id&quot;);
}
]]></script>
</div></div><p>Then Camel will read this header and use it as the destination instead of the one configured on the endpoint. So, in this example Camel sends the message to <code>activemq:queue:order:2</code>, assuming the <code>id</code> value was 2.</p><p>If both the <code>CamelJmsDestination</code> and the <code>CamelJmsDestinationName</code> headers are set, <code>CamelJmsDestination</code> takes priority. Keep in mind that the JMS producer removes both <code>CamelJmsDestination</code> and <code>CamelJmsDestinationName</code> headers from the exchange and do not propagate them to the created JMS message<span class="entry">&#160;</span>in order to avoid the accidental loops in the routes (in scenarios when the message will be forwarded to the another JMS endpoint).</p><h3 id="JMS-ConfiguringdifferentJMSproviders">Configuring different JMS providers</h3><p>You can configure your JMS provider in <a shape="rect" href="spring.html">Spring</a> XML as follows:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: xml; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[
&lt;camelContext id=&quot;camel&quot; xmlns=&quot;http://camel.apache.org/schema/spring&quot;&gt;
    &lt;jmxAgent id=&quot;agent&quot; disabled=&quot;true&quot;/&gt;
&lt;/camelContext&gt;

&lt;bean id=&quot;activemq&quot; class=&quot;org.apache.activemq.camel.component.ActiveMQComponent&quot;&gt;
  &lt;property name=&quot;connectionFactory&quot;&gt;
    &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;
      &lt;property name=&quot;brokerURL&quot; value=&quot;vm://localhost?broker.persistent=false&amp;amp;broker.useJmx=false&quot;/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
]]></script>
</div></div>Basically, you can configure as many JMS component instances as you wish and give them <strong>a unique name using the</strong> <code><strong>id</strong></code> <strong>attribute</strong>. The preceding example configures an <code>activemq</code> component. You could do the same to configure MQSeries, TibCo, BEA, Sonic and so on.<p>Once you have a named JMS component, you can then refer to endpoints within that component using URIs. For example for the component name, <code>activemq</code>, you can then refer to destinations using the URI format, <code>activemq:[queue:|topic:]destinationName</code>. You can use the same approach for all other JMS providers.</p><p>This works by the SpringCamelContext lazily fetching components from the spring context for the scheme name you use for <a shape="rect" href="endpoint.html">Endpoint</a> <a shape="rect" href="uris.html">URIs</a> and having the <a shape="rect" href="component.html">Component</a> resolve the endpoint URIs.</p><h4 id="JMS-UsingJNDItofindtheConnectionFactory">Using JNDI to find the ConnectionFactory</h4><p>If you are using a J2EE container, you might need to look up JNDI to find the JMS <code>ConnectionFactory</code> rather than use the usual <code>&lt;bean&gt;</code> mechanism in Spring. You can do this using Spring's factory bean or the new Spring XML namespace. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: xml; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[&lt;bean id=&quot;weblogic&quot; class=&quot;org.apache.camel.component.jms.JmsComponent&quot;&gt;
  &lt;property name=&quot;connectionFactory&quot; ref=&quot;myConnectionFactory&quot;/&gt;
&lt;/bean&gt;

&lt;jee:jndi-lookup id=&quot;myConnectionFactory&quot; jndi-name=&quot;jms/connectionFactory&quot;/&gt;
]]></script>
</div></div><p>See <a shape="rect" class="external-link" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/xsd-config.html#xsd-config-body-schemas-jee" rel="nofollow">The jee schema</a> in the Spring reference documentation for more details about JNDI lookup.</p><h3 id="JMS-ConcurrentConsuming">Concurrent Consuming</h3><p>A common requirement with JMS is to consume messages concurrently in multiple threads in order to make an application more responsive. You can set the <code>concurrentConsumers</code> option to specify the number of threads servicing the JMS endpoint, as follows:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(&quot;jms:SomeQueue?concurrentConsumers=20&quot;).
  bean(MyClass.class);
]]></script>
</div></div><p>You can configure this option in one of the following ways:</p><ul><li>On the <code>JmsComponent</code>,</li><li>On the endpoint URI or,</li><li>By invoking <code>setConcurrentConsumers()</code> directly on the <code>JmsEndpoint</code>.</li></ul><h4 id="JMS-ConcurrentConsumingwithasyncconsumer">Concurrent Consuming with async consumer</h4><p>Notice that each concurrent consumer will only pickup the next available message from the JMS broker, when the current message has been fully processed. You can set the option <code>asyncConsumer=true</code> to let the consumer pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the <a shape="rect" href="asynchronous-routing-engine.html">Asynchronous Routing Engine</a>). See more details in the table on top of the page about the <code>asyncConsumer</code> option.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(&quot;jms:SomeQueue?concurrentConsumers=20&amp;asyncConsumer=true&quot;).
  bean(MyClass.class);
]]></script>
</div></div><h3 id="JMS-Request-replyoverJMS">Request-reply over JMS</h3><p>Camel supports <a shape="rect" href="request-reply.html">Request Reply</a> over JMS. In essence the MEP of the Exchange should be <code>InOut</code> when you send a message to a JMS queue.</p><p>Camel offers a number of options to configure request/reply over JMS that influence performance and clustered environments. The table below summaries the options.</p><div class="confluenceTableSmall"><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>Option</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Performance</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Cluster</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Temporary</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Fast</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Yes</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>A temporary queue is used as reply queue, and automatic created by Camel. To use this do <strong>not</strong> specify a replyTo queue name. And you can optionally configure <code>replyToType=Temporary</code> to make it stand out that temporary queues are in use.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Shared</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Slow</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Yes</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>A shared persistent queue is used as reply queue. The queue must be created beforehand, although some brokers can create them on the fly such as Apache ActiveMQ. To use this you must specify the replyTo queue name. And you can optionally configure <code>replyToType=Shared</code> to make it stand out that shared queues are in use. A shared queue can be used in a clustered environment with multiple nodes running this Camel application at the same time. All using the same shared reply queue. This is possible because JMS Message selectors are used to correlate expected reply messages; this impacts performance though. JMS Message selectors is slower, and therefore not as fast as <code>Temporary</code> or <code>Exclusive</code> queues. See further below how to tweak this for better performance.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Exclusive</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Fast</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>No (*Yes)</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>An exclusive persistent queue is used as reply queue. The queue must be created beforehand, although some brokers can create them on the fly such as Apache ActiveMQ. To use this you must specify the replyTo queue name. And you <strong>must</strong> configure <code>replyToType=Exclusive</code> to instruct Camel to use exclusive queues, as <code>Shared</code> is used by default, if a <code>replyTo</code> queue name was configured. When using exclusive reply queues, then JMS Message selectors are <strong>not</strong> in use, and therefore other applications must not use this queue as well. An exclusive queue <strong>cannot</strong> be used in a clustered environment with multiple nodes running this Camel application at the same time; as we do not have control if the reply queue comes back to the same node that sent the request message; that is why shared queues use JMS Message selectors to make sure of this. <strong>Though</strong> if you configure each Exclusive reply queue with an unique name per node, then you can run this in a clustered environment. As then the reply message will be sent back to that queue for the given node, that awaits the reply message.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>concurrentConsumers</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Fast</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Yes</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.10.3:</strong> Allows to process reply messages concurrently using concurrent message listeners in use. You can specify a range using the <code>concurrentConsumers</code> and <code>maxConcurrentConsumers</code> options. <strong>Notice:</strong> That using <code>Shared</code> reply queues may not work as well with concurrent listeners, so use this option with care.</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>maxConcurrentConsumers</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Fast</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>Yes</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>Camel 2.10.3:</strong> Allows to process reply messages concurrently using concurrent message listeners in use. You can specify a range using the <code>concurrentConsumers</code> and <code>maxConcurrentConsumers</code> options. <strong>Notice:</strong> That using <code>Shared</code> reply queues may not work as well with concurrent listeners, so use this option with care.</p></td></tr></tbody></table></div></div><p>The <code>JmsProducer</code> detects the <code>InOut</code> and provides a <code>JMSReplyTo</code> header with the reply destination to be used. By default Camel uses a temporary queue, but you can use the <code>replyTo</code> option on the endpoint to specify a fixed reply queue (see more below about fixed reply queue).</p><p>Camel will automatic setup a consumer which listen on the reply queue, so you should <strong>not</strong> do anything.<br clear="none"> This consumer is a Spring <code>DefaultMessageListenerContainer</code> which listen for replies. However it's fixed to 1 concurrent consumer.<br clear="none"> That means replies will be processed in sequence as there are only 1 thread to process the replies. If you want to process replies faster, then we need to use concurrency. But <strong>not</strong> using the <code>concurrentConsumer</code> option. We should use the <code>threads</code> from the Camel DSL instead, as shown in the route below:</p><div class="confluence-information-macro confluence-information-macro-tip"><span class="aui-icon aui-icon-small aui-iconfont-approve confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>Instead of using threads, then use concurrentConsumers option if using Camel 2.10.3 or better. See further below.</p></div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(xxx)
.inOut().to(&quot;activemq:queue:foo&quot;)
.threads(5)
.to(yyy)
.to(zzz);
]]></script>
</div></div><p>In this route we instruct Camel to route replies <a shape="rect" href="async.html">asynchronously</a> using a thread pool with 5 threads.</p><p>From <strong>Camel 2.10.3</strong> onwards you can now configure the listener to use concurrent threads using the <code>concurrentConsumers</code> and <code>maxConcurrentConsumers</code> options. This allows you to easier configure this in Camel as shown below:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(xxx)
.inOut().to(&quot;activemq:queue:foo?concurrentConsumers=5&quot;)
.to(yyy)
.to(zzz);
]]></script>
</div></div><h4 id="JMS-Request-replyoverJMSandusingasharedfixedreplyqueue">Request-reply over JMS and using a shared fixed reply queue</h4><p>If you use a fixed reply queue when doing <a shape="rect" href="request-reply.html">Request Reply</a> over JMS as shown in the example below, then pay attention.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(xxx)
.inOut().to(&quot;activemq:queue:foo?replyTo=bar&quot;)
.to(yyy)
]]></script>
</div></div><p>In this example the fixed reply queue named "bar" is used. By default Camel assumes the queue is shared when using fixed reply queues, and therefore it uses a <code>JMSSelector</code> to only pickup the expected reply messages (eg based on the <code>JMSCorrelationID</code>). See next section for exclusive fixed reply queues. That means its not as fast as temporary queues. You can speedup how often Camel will pull for reply messages using the <code>receiveTimeout</code> option. By default its 1000 millis. So to make it faster you can set it to 250 millis to pull 4 times per second as shown:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(xxx)
.inOut().to(&quot;activemq:queue:foo?replyTo=bar&amp;receiveTimeout=250&quot;)
.to(yyy)
]]></script>
</div></div><p>Notice this will cause the Camel to send pull requests to the message broker more frequent, and thus require more network traffic.<br clear="none"> It is generally recommended to use temporary queues if possible.</p><h4 id="JMS-Request-replyoverJMSandusinganexclusivefixedreplyqueue">Request-reply over JMS and using an exclusive fixed reply queue</h4><p><strong>Available as of Camel 2.9</strong></p><p>In the previous example, Camel would anticipate the fixed reply queue named "bar" was shared, and thus it uses a <code>JMSSelector</code> to only consume reply messages which it expects. However there is a drawback doing this as JMS selectos is slower. Also the consumer on the reply queue is slower to update with new JMS selector ids. In fact it only updates when the <code>receiveTimeout</code> option times out, which by default is 1 second. So in theory the reply messages could take up till about 1 sec to be detected. On the other hand if the fixed reply queue is exclusive to the Camel reply consumer, then we can avoid using the JMS selectors, and thus be more performant. In fact as fast as using temporary queues. So in <strong>Camel 2.9</strong> onwards we introduced the <code>ReplyToType</code> option which you can configure to <code>Exclusive</code><br clear="none"> to tell Camel that the reply queue is exclusive as shown in the example below:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(xxx)
.inOut().to(&quot;activemq:queue:foo?replyTo=bar&amp;replyToType=Exclusive&quot;)
.to(yyy)
]]></script>
</div></div><p>Mind that the queue must be exclusive to each and every endpoint. So if you have two routes, then they each need an unique reply queue as shown in the next example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(xxx)
.inOut().to(&quot;activemq:queue:foo?replyTo=bar&amp;replyToType=Exclusive&quot;)
.to(yyy)

from(aaa)
.inOut().to(&quot;activemq:queue:order?replyTo=order.reply&amp;replyToType=Exclusive&quot;)
.to(bbb)
]]></script>
</div></div><p>The same applies if you run in a clustered environment. Then each node in the cluster must use an unique reply queue name. As otherwise each node in the cluster may pickup messages which was intended as a reply on another node. For clustered environments its recommended to use shared reply queues instead.</p><h3 id="JMS-Synchronizingclocksbetweensendersandreceivers">Synchronizing clocks between senders and receivers</h3><p>When doing messaging between systems, its desirable that the systems have synchronized clocks. For example when sending a <a shape="rect" href="jms.html">JMS</a> message, then you can set a time to live value on the message. Then the receiver can inspect this value, and determine if the message is already expired, and thus drop the message instead of consume and process it. However this requires that both sender and receiver have synchronized clocks. If you are using <a shape="rect" class="external-link" href="http://activemq.apache.org/">ActiveMQ</a> then you can use the <a shape="rect" class="external-link" href="http://activemq.apache.org/timestampplugin.html">timestamp plugin</a> to synchronize clocks.</p><h3 id="JMS-Abouttimetolive">About time to live</h3><p>Read first above about synchronized clocks.</p><p>When you do request/reply (InOut) over <a shape="rect" href="jms.html">JMS</a> with Camel then Camel uses a timeout on the sender side, which is default 20 seconds from the <code>requestTimeout</code> option. You can control this by setting a higher/lower value. However the time to live value is still set on the <a shape="rect" href="jms.html">JMS</a> message being send. So that requires the clocks to be synchronized between the systems. If they are not, then you may want to disable the time to live value being set. This is now possible using the <code>disableTimeToLive</code> option from <strong>Camel 2.8</strong> onwards. So if you set this option to <code>disableTimeToLive=true</code>, then Camel does <strong>not</strong> set any time to live value when sending <a shape="rect" href="jms.html">JMS</a> messages. <strong>But</strong> the request timeout is still active. So for example if you do request/reply over <a shape="rect" href="jms.html">JMS</a> and have disabled time to live, then Camel will still use a timeout by 20 seconds (the <code>requestTimeout</code> option). That option can of course also be configured. So the two options <code>requestTimeout</code> and <code>disableTimeToLive</code> gives you fine grained control when doing request/reply.</p><p>From <strong>Camel 2.13/2.12.3</strong> onwards you can provide a header in the message to override and use as the request timeout value instead of the endpoint configured value. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[   from(&quot;direct:someWhere&quot;)
     .to(&quot;jms:queue:foo?replyTo=bar&amp;requestTimeout=30s&quot;)
     .to(&quot;bean:processReply&quot;);
]]></script>
</div></div><p>In the route above we have a endpoint configured <code>requestTimeout</code> of 30 seconds. So Camel will wait up till 30 seconds for that reply message to come back on the bar queue. If no reply message is received then a <code>org.apache.camel.ExchangeTimedOutException</code> is set on the <a shape="rect" href="exchange.html">Exchange</a> and Camel continues routing the message, which would then fail due the exception, and Camel's error handler reacts.</p><p>If you want to use a per message timeout value, you can set the header with key <code>org.apache.camel.component.jms.JmsConstants#JMS_REQUEST_TIMEOUT</code> which has constant value <code>"CamelJmsRequestTimeout"</code> with a timeout value as long type.</p><p>For example we can use a bean to compute the timeout value per individual message, such as calling the <code>"whatIsTheTimeout"</code> method on the service bean as shown below:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[   from(&quot;direct:someWhere&quot;)
     .setHeader(&quot;CamelJmsRequestTimeout&quot;, method(ServiceBean.class, &quot;whatIsTheTimeout&quot;))
     .to(&quot;jms:queue:foo?replyTo=bar&amp;requestTimeout=30s&quot;)
     .to(&quot;bean:processReply&quot;);
]]></script>
</div></div><p>When you do fire and forget (InOut) over <a shape="rect" href="jms.html">JMS</a> with Camel then Camel by default does <strong>not</strong> set any time to live value on the message. You can configure a value by using the <code>timeToLive</code> option. For example to indicate a 5 sec., you set <code>timeToLive=5000</code>. The option <code>disableTimeToLive</code> can be used to force disabling the time to live, also for InOnly messaging. The <code>requestTimeout</code> option is not being used for InOnly messaging.</p><h3 id="JMS-EnablingTransactedConsumption">Enabling Transacted Consumption</h3><p><span class="confluence-anchor-link" id="JMS-transactedConsumption"></span></p><p>A common requirement is to consume from a queue in a transaction and then process the message using the Camel route. To do this, just ensure that you set the following properties on the component/endpoint:</p><ul><li><code>transacted</code> = true</li><li><code>transactionManager</code> = a <em>Transsaction Manager</em> - typically the <code>JmsTransactionManager</code></li></ul><p>See the <a shape="rect" href="transactional-client.html">Transactional Client</a> EIP pattern for further details.</p><div class="confluence-information-macro confluence-information-macro-information"><p class="title">Transactions and [Request Reply] over JMS</p><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>When using <a shape="rect" href="request-reply.html">Request Reply</a> over JMS you cannot use a single transaction; JMS will not send any messages until a commit is performed, so the server side won't receive anything at all until the transaction commits. Therefore to use <a shape="rect" href="request-reply.html">Request Reply</a> you must commit a transaction after sending the request and then use a separate transaction for receiving the response.</p><p>To address this issue the JMS component uses different properties to specify transaction use for oneway messaging and request reply messaging:</p><p>The <code>transacted</code> property applies <strong>only</strong> to the InOnly message <a shape="rect" href="exchange-pattern.html">Exchange Pattern</a> (MEP).</p><p>The <code>transactedInOut</code> property applies to the InOut(<a shape="rect" href="request-reply.html">Request Reply</a>) message <a shape="rect" href="exchange-pattern.html">Exchange Pattern</a> (MEP).</p><p>If you want to use transactions for <a shape="rect" href="request-reply.html">Request Reply</a>(InOut MEP), you <strong>must</strong> set <code>transactedInOut=true</code>.</p></div></div><p><strong>Available as of Camel 2.10</strong></p><p>You can leverage the <a shape="rect" class="external-link" href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jms/listener/AbstractPollingMessageListenerContainer.html#setSessionTransacted(boolean)" rel="nofollow">DMLC transacted session API</a> using the following properties on component/endpoint:</p><ul><li><code>transacted</code> = true</li><li><code>lazyCreateTransactionManager</code> = false</li></ul><p>The benefit of doing so is that the cacheLevel setting will be honored when using local transactions without a configured TransactionManager. When a TransactionManager is configured, no caching happens at DMLC level and its necessary to rely on a pooled connection factory. For more details about this kind of setup see <a shape="rect" class="external-link" href="http://tmielke.blogspot.com/2012/03/camel-jms-with-transactions-lessons.html" rel="nofollow">here</a> and <a shape="rect" class="external-link" href="http://forum.springsource.org/showthread.php?123631-JMS-DMLC-not-caching connection-when-using-TX-despite-cacheLevel-CACHE_CONSUMER&amp;p=403530&amp;posted=1#post403530" rel="nofollow">here</a>.</p><h3 id="JMS-UsingJMSReplyToforlatereplies">Using JMSReplyTo for late replies</h3><p>When using Camel as a JMS listener, it sets an Exchange property with the value of the ReplyTo <code>javax.jms.Destination</code> object, having the key <code>ReplyTo</code>. You can obtain this <code>Destination</code> as follows:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[Destination replyDestination = exchange.getIn().getHeader(JmsConstants.JMS_REPLY_DESTINATION, Destination.class);
]]></script>
</div></div><p>And then later use it to send a reply using regular JMS or Camel.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[    // we need to pass in the JMS component, and in this sample we use ActiveMQ
    JmsEndpoint endpoint = JmsEndpoint.newInstance(replyDestination, activeMQComponent);
    // now we have the endpoint we can use regular Camel API to send a message to it
    template.sendBody(endpoint, &quot;Here is the late reply.&quot;);
]]></script>
</div></div><p>A different solution to sending a reply is to provide the <code>replyDestination</code> object in the same Exchange property when sending. Camel will then pick up this property and use it for the real destination. The endpoint URI must include a dummy destination, however. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[    // we pretend to send it to some non existing dummy queue
    template.send(&quot;activemq:queue:dummy, new Processor() {
        public void process(Exchange exchange) throws Exception {
            // and here we override the destination with the ReplyTo destination object so the message is sent to there instead of dummy
            exchange.getIn().setHeader(JmsConstants.JMS_DESTINATION, replyDestination);
            exchange.getIn().setBody(&quot;Here is the late reply.&quot;);
        }
    }
]]></script>
</div></div><h3 id="JMS-Usingarequesttimeout">Using a request timeout</h3><p>In the sample below we send a <a shape="rect" href="request-reply.html">Request Reply</a> style message <a shape="rect" href="exchange.html">Exchange</a> (we use the <code>requestBody</code> method = <code>InOut</code>) to the slow queue for further processing in Camel and we wait for a return reply:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[
// send a in-out with a timeout for 5 sec
Object out = template.requestBody(&quot;activemq:queue:slow?requestTimeout=5000&quot;, &quot;Hello World&quot;);
]]></script>
</div></div><h3 id="JMS-Samples">Samples</h3><p>JMS is used in many examples for other components as well. But we provide a few samples below to get started.</p><h4 id="JMS-ReceivingfromJMS">Receiving from JMS</h4><p>In the following sample we configure a route that receives JMS messages and routes the message to a POJO:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[   from(&quot;jms:queue:foo&quot;).
     to(&quot;bean:myBusinessLogic&quot;);
]]></script>
</div></div><p>You can of course use any of the EIP patterns so the route can be context based. For example, here's how to filter an order topic for the big spenders:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(&quot;jms:topic:OrdersTopic&quot;).
  filter().method(&quot;myBean&quot;, &quot;isGoldCustomer&quot;).
    to(&quot;jms:queue:BigSpendersQueue&quot;);
]]></script>
</div></div><h4 id="JMS-SendingtoaJMS">Sending to a JMS</h4><p>In the sample below we poll a file folder and send the file content to a JMS topic. As we want the content of the file as a <code>TextMessage</code> instead of a <code>BytesMessage</code>, we need to convert the body to a <code>String</code>:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(&quot;file://orders&quot;).
  convertBodyTo(String.class).
  to(&quot;jms:topic:OrdersTopic&quot;);
]]></script>
</div></div><h4 id="JMS-UsingAnnotations">Using <a shape="rect" href="bean-integration.html">Annotations</a></h4><p>Camel also has annotations so you can use <a shape="rect" href="pojo-consuming.html">POJO Consuming</a> and <a shape="rect" href="pojo-producing.html">POJO Producing</a>.</p><h4 id="JMS-SpringDSLsample">Spring DSL sample</h4><p>The preceding examples use the Java DSL. Camel also supports Spring XML DSL. Here is the big spender sample using Spring DSL:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: xml; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[&lt;route&gt;
  &lt;from uri=&quot;jms:topic:OrdersTopic&quot;/&gt;
  &lt;filter&gt;
    &lt;method bean=&quot;myBean&quot; method=&quot;isGoldCustomer&quot;/&gt;
    &lt;to uri=&quot;jms:queue:BigSpendersQueue&quot;/&gt;
  &lt;/filter&gt;
&lt;/route&gt;
]]></script>
</div></div><h4 id="JMS-Othersamples">Other samples</h4><p>JMS appears in many of the examples for other components and EIP patterns, as well in this Camel documentation. So feel free to browse the documentation. If you have time, check out the this tutorial that uses JMS but focuses on how well Spring Remoting and Camel works together <a shape="rect" href="tutorial-jmsremoting.html">Tutorial-JmsRemoting</a>.</p><h4 id="JMS-UsingJMSasaDeadLetterQueuestoringExchange">Using JMS as a Dead Letter Queue storing Exchange</h4><p>Normally, when using <a shape="rect" href="jms.html">JMS</a> as the transport, it only transfers the body and headers as the payload. If you want to use <a shape="rect" href="jms.html">JMS</a> with a <a shape="rect" href="dead-letter-channel.html">Dead Letter Channel</a>, using a JMS queue as the Dead Letter Queue, then normally the caused Exception is not stored in the JMS message. You can, however, use the <strong>transferExchange</strong> option on the JMS dead letter queue to instruct Camel to store the entire <a shape="rect" href="exchange.html">Exchange</a> in the queue as a <code>javax.jms.ObjectMessage</code> that holds a <code>org.apache.camel.impl.DefaultExchangeHolder</code>. This allows you to consume from the Dead Letter Queue and retrieve the caused exception from the Exchange property with the key <code>Exchange.EXCEPTION_CAUGHT</code>. The demo below illustrates this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[// setup error handler to use JMS as queue and store the entire Exchange
errorHandler(deadLetterChannel(&quot;jms:queue:dead?transferExchange=true&quot;));
]]></script>
</div></div><p>Then you can consume from the JMS queue and analyze the problem:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[from(&quot;jms:queue:dead&quot;).to(&quot;bean:myErrorAnalyzer&quot;);

// and in our bean
String body = exchange.getIn().getBody();
Exception cause = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
// the cause message is
String problem = cause.getMessage();
]]></script>
</div></div><h4 id="JMS-UsingJMSasaDeadLetterChannelstoringerroronly">Using JMS as a Dead Letter Channel storing error only</h4><p>You can use JMS to store the cause error message or to store a custom body, which you can initialize yourself. The following example uses the <a shape="rect" href="message-translator.html">Message Translator</a> EIP to do a transformation on the failed exchange before it is moved to the <a shape="rect" href="jms.html">JMS</a> dead letter queue:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[// we sent it to a seda dead queue first
errorHandler(deadLetterChannel(&quot;seda:dead&quot;));

// and on the seda dead queue we can do the custom transformation before its sent to the JMS queue
from(&quot;seda:dead&quot;).transform(exceptionMessage()).to(&quot;jms:queue:dead&quot;);
]]></script>
</div></div><p>Here we only store the original cause error message in the transform. You can, however, use any <a shape="rect" href="expression.html">Expression</a> to send whatever you like. For example, you can invoke a method on a Bean or use a custom processor.</p><h3 id="JMS-SendinganInOnlymessageandkeepingtheJMSReplyToheader">Sending an InOnly message and keeping the JMSReplyTo header</h3><p>When sending to a <a shape="rect" href="jms.html">JMS</a> destination using <strong>camel-jms</strong> the producer will use the MEP to detect if its InOnly or InOut messaging. However there can be times where you want to send an InOnly message but keeping the JMSReplyTo header. To do so you have to instruct Camel to keep it, otherwise the JMSReplyTo header will be dropped.</p><p>For example to send an InOnly message to the foo queue, but with a JMSReplyTo with bar queue you can do as follows:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[        template.send(&quot;activemq:queue:foo?preserveMessageQos=true&quot;, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(&quot;World&quot;);
                exchange.getIn().setHeader(&quot;JMSReplyTo&quot;, &quot;bar&quot;);
            }
        });
]]></script>
</div></div><p>Notice we use <code>preserveMessageQos=true</code> to instruct Camel to keep the JMSReplyTo header.</p><h3 id="JMS-SettingJMSprovideroptionsonthedestination">Setting JMS provider options on the destination</h3><p>Some JMS providers, like IBM's WebSphere MQ need options to be set on the JMS destination. For example, you may need to specify the targetClient option. Since targetClient is a WebSphere MQ option and not a Camel URI option, you need to set that on the JMS destination name like so:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[...
.setHeader(&quot;CamelJmsDestinationName&quot;, constant(&quot;queue:///MY_QUEUE?targetClient=1&quot;))
.to(&quot;wmq:queue:MY_QUEUE?useMessageIDAsCorrelationID=true&quot;);
]]></script>
</div></div><p>Some versions of WMQ won't accept this option on the destination name and you will get an exception like:</p><blockquote><p>com.ibm.msg.client.jms.DetailedJMSException: JMSCC0005: The specified value 'MY_QUEUE?targetClient=1' is not allowed for 'XMSC_DESTINATION_NAME'</p></blockquote><p>A workaround is to use a custom DestinationResolver:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<script class="brush: java; gutter: false; theme: Default" type="syntaxhighlighter"><![CDATA[JmsComponent wmq = new JmsComponent(connectionFactory);

wmq.setDestinationResolver(new DestinationResolver(){
    public Destination resolveDestinationName(Session session, String destinationName, boolean pubSubDomain) throws JMSException {
        MQQueueSession wmqSession = (MQQueueSession) session;
        return wmqSession.createQueue(&quot;queue:///&quot; + destinationName + &quot;?targetClient=1&quot;);
    }
});
]]></script>
</div></div><p></p><h3 id="JMS-SeeAlso">See Also</h3>
<ul><li><a shape="rect" href="configuring-camel.html">Configuring Camel</a></li><li><a shape="rect" href="component.html">Component</a></li><li><a shape="rect" href="endpoint.html">Endpoint</a></li><li><a shape="rect" href="getting-started.html">Getting Started</a></li></ul><ul class="alternate"><li><a shape="rect" href="transactional-client.html">Transactional Client</a></li><li><a shape="rect" href="bean-integration.html">Bean Integration</a></li><li><a shape="rect" href="tutorial-jmsremoting.html">Tutorial-JmsRemoting</a></li><li><a shape="rect" class="external-link" href="http://activemq.apache.org/jmstemplate-gotchas.html">JMSTemplate gotchas</a></li></ul></div>
        </td>
        <td valign="top">
          <div class="navigation">
            <div class="navigation_top">
                <!-- NavigationBar -->
<div class="navigation_bottom" id="navigation_bottom"><h3 id="Navigation-Overview"><a shape="rect" href="overview.html">Overview</a></h3><ul class="alternate"><li><a shape="rect" href="index.html">Home</a></li><li><a shape="rect" href="download.html">Download</a></li><li><a shape="rect" href="getting-started.html">Getting Started</a></li><li><a shape="rect" href="faq.html">FAQ</a></li></ul><h3 id="Navigation-Documentation"><a shape="rect" href="documentation.html">Documentation</a></h3><ul class="alternate"><li><a shape="rect" href="user-guide.html">User Guide</a></li><li><a shape="rect" href="manual.html">Manual</a></li><li><a shape="rect" href="books.html">Books</a></li><li><a shape="rect" href="tutorials.html">Tutorials</a></li><li><a shape="rect" href="examples.html">Examples</a></li><li><a shape="rect" href="cookbook.html">Cookbook</a></li><li><a shape="rect" href="architecture.html">Architecture</a></li><li><a shape="rect" href="enterprise-integration-patterns.html">Enterprise Integration Patterns</a></li><li><a shape="rect" href="dsl.html">DSL</a></li><li><a shape="rect" href="components.html">Components</a></li><li><a shape="rect" href="data-format.html">Data Format</a></li><li><a shape="rect" href="languages.html">Languages</a></li><li><a shape="rect" href="security.html">Security</a></li><li><a shape="rect" href="security-advisories.html">Security Advisories</a></li></ul><h3 id="Navigation-Search">Search</h3><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="007878419884033443453:m5nhvy4hmyq">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script><h3 id="Navigation-Community"><a shape="rect" href="community.html">Community</a></h3><ul class="alternate"><li><a shape="rect" href="support.html">Support</a></li><li><a shape="rect" href="contributing.html">Contributing</a></li><li><a shape="rect" href="discussion-forums.html">Discussion Forums</a></li><li><a shape="rect" href="mailing-lists.html">Mailing Lists</a></li><li><a shape="rect" href="user-stories.html">User Stories</a></li><li><a shape="rect" href="news.html">News</a></li><li><a shape="rect" href="articles.html">Articles</a></li><li><a shape="rect" href="site.html">Site</a></li><li><a shape="rect" href="team.html">Team</a></li><li><a shape="rect" class="external-link" href="http://camel-extra.googlecode.com/" rel="nofollow">Camel Extra</a></li></ul><h3 id="Navigation-Developers"><a shape="rect" href="developers.html">Developers</a></h3><ul class="alternate"><li><a shape="rect" href="developers.html">Developer Guide</a></li><li><a shape="rect" href="source.html">Source</a></li><li><a shape="rect" href="building.html">Building</a></li><li><a shape="rect" href="javadoc.html">JavaDoc</a></li><li><a shape="rect" href="irc-room.html">IRC Room</a></li></ul><h3 id="Navigation-ApacheSoftwareFoundation">Apache Software Foundation</h3><ul class="alternate"><li><a shape="rect" class="external-link" href="http://www.apache.org/licenses/">License</a></li><li><a shape="rect" class="external-link" href="http://www.apache.org/foundation/sponsorship.html">Sponsorship</a></li><li><a shape="rect" class="external-link" href="http://www.apache.org/foundation/thanks.html">Thanks</a></li><li><a shape="rect" class="external-link" href="http://www.apache.org/security/">Security</a></li></ul></div>
                <!-- NavigationBar -->
            </div>
          </div>
        </td>
        </tr>
	</tbody>
        </table>


        <div class="bottom_red_bar"></div>
      </div>
    </div>
  </div>
</div>
<div class="black_box">
<div class="footer">
  <div class="footer_l">
    <div class="footer_r">
      <div>
        <a href="$base/privacy-policy.html">Privacy Policy</a> -
        (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=51893">edit page</a>)
   	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51893&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)
      </div>
    </div>
  </div>
</div>
</div>
</div>
<div class="design_attribution">
&copy; 2004-2015 The Apache Software Foundation.
<br>          
Apache Camel, Camel, Apache, the Apache feather logo, and the Apache Camel project logo are trademarks of The Apache Software Foundation.  All other marks mentioned may be trademarks or registered trademarks of their respective owners.
<br>
<a href="http://hiramchirino.com">Graphic Design By Hiram</a>
</div>

<!-- Camel committers that would like access to the Analytics, send a note to private@camel.apache.org -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>


